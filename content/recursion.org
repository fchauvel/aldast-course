#+titile: Recursion
#+subtitle: A Peek at functional programming
#+author: Franck Chauvel
#+language: en

#+SETUPFILE: ../templates/style.org


* Introduction

  - Hook: How to remove the loop in the sum-of-integer problem

  #+name: code:sum-of-integers
  #+begin_src python
    def sum_of_integers(n):
        sum = 0
        for i in range(n+1):
           sum += i
        return sum
  #+end_src

  #+name: code:sum-of-integer-test
  #+header: :results output
  #+header: :noweb strip-export
  #+begin_src python
    <<code:sum-of-integers>>
    print(sum_of_integers(10))
  #+end_src

  #+RESULTS: code:sum-of-integer-test
  : 55

* What is "Recursion"?

** Definition?

** A Common Concept
   - In nature
   - In cooking
   - In Arts: The Droste Effect
   - In Maths
     - Proofs by Induction
     - Fractals
     - Difference equation
     - Recurrence relation
           
  - What is "recursion"?
    - Drost effec
      - self-similarity
    - Example:
      - recursive definition

* Examples

** Sum of Integers

   #+name: code:sum-of-integers-recursive
   #+begin_src python
     def sum_of_integers(n):
        if n==1:
           return 1
        return n + sum_of_integers(n-1)
   #+end_src


   #+name: code:sum-of-integer-recursive-test
   #+header: :noweb strip-export
   #+header: :results output
   #+begin_src python
     <<code:sum-of-integers-recursive>>
     print(sum_of_integers(10))
   #+end_src

   #+RESULTS: code:sum-of-integer-recursive-test
   : 55

** Factorial

   #+name: code:factorial
   #+begin_src python
     def factorial(n):
        total = 1
        for each in range(1, n+1):
           total *= each
        return total
   #+end_src

   #+name: code:factorial-test
   #+header: :noweb strip-export
   #+header: :results output
   #+header: :python python3
   #+begin_src python
   <<code:factorial>>
   print("4! =", factorial(4))
   print("5! =", factorial(5))
   print("6! =", factorial(6))
   #+end_src

   #+RESULTS: code:factorial-test
   : 4! = 24
   : 5! = 120
   : 6! = 720


   #+name: code:factorial-recursive
   #+begin_src python
     def factorial(n):
        if n == 1:
           return 1
        return n * factorial(n-1)
   #+end_src


   #+name: code:factorial-recursive-test
   #+header: :noweb strip-export
   #+header: :results output
   #+header: :python python3
   #+begin_src python
       <<code:factorial-recursive>>
       print("4! =", factorial(4))
       print("5! =", factorial(5))
       print("6! =", factorial(6))
   #+end_src

   #+RESULTS: code:factorial-recursive-test
   : 4! = 24
   : 5! = 120
   : 6! = 720

   
** Binary Search

   #+name: code:binary-search
   #+begin_src python
     def search(array, value):
         lower = 0
         upper = len(array)
         while (upper - lower) > 1:
             split = (upper + lower) // 2
             if value == array[split]:
                 return split
             elif value < array[split]:
                upper = split
             else:
                lower = split
         return -1
   #+end_src

   #+name: code:binary-search-test
   #+header: :python python3
   #+header: :noweb strip-export
   #+header: :results output
   #+begin_src python
     <<code:binary-search>>
     array = [1, 3, 5, 7, 8, 9, 10]
     print("index(5) =", search(array, 5))
     print("index(10) =", search(array, 10))
   #+end_src

   #+RESULTS: code:binary-search-test
   : index(5) = 2
   : index(10) = 6


   #+name: code:binary-search-recursive
   #+begin_src python
     def do_search(array, lower, upper, value):
        split = (lower + upper) // 2
        if value == array[split]:
           return split
        elif value < array[split]:
           return do_search(array, lower, split, value)
        else:
           return do_search(array, split, upper, value)

     def search(array, value):
         return do_search(array, 0, len(array), value)
   #+end_src

   #+name: code:binary-search-recursive-test
   #+header: :noweb strip-export
   #+header: :python python3
   #+header: :results output
   #+begin_src python
     <<code:binary-search-recursive>>
     array = [1, 3, 5, 7, 8, 9, 10]
     print("index(5) =", search(array, 5))
     print("index(10) =", search(array, 10))
   #+end_src

   #+RESULTS: code:binary-search-recursive-test
   : index(5) = 2
   : index(10) = 6
   
   
* How to Design "Recursive" Programs?

  - Why?
    - Elegance / simplicity

  - Decomposition
  
  - Recursive Thinking      
    - Find a self-similar sub problem (simpler sub problem)
    - Definition
      - base cases
      - recursive cases
    - recursion diagram

  - Three Musts for Recursion:
    1. Your code must have a case for all valid inputs
    2. You must have a base case that makes no recursive calls
    3. When you make a recursive call it should be to a simpler
       instance and make forward progress towards the base case.

  - Leap of faith

* The Cost of Recursive Calls

** Expressiveness
  
  - Recursion vs. iteration
    - Theory: recursion = iteration?
      - every iteration can be converted into a recursive function
      - difference equation


** Efficiency
   
  #+header: :noweb strip-export
  #+header: :tangle experiments/recursion/iteration.py
  #+header: :mkdirp yes
  #+begin_src python
    <<code:sum-of-integers>>
    print(sum_of_integers(1000))
  #+end_src

  #+name: sum-of-integers-stress-test
  #+hedaer: :exports both
  #+header: :results output
  #+begin_src shell
  python3 experiments/recursion/iteration.py
  #+end_src

  #+RESULTS: sum-of-integers-stress-test
  : 500500


  #+header: :noweb strip-export
  #+header: :tangle experiments/recursion/recursion.py
  #+header: :mkdirp yes
  #+begin_src python
    <<code:sum-of-integers-recursive>>
    print(sum_of_integers(1000))
  #+end_src

  #+name: sum-of-integers-recursive-stress-test
  #+header: :exports both
  #+header: :results verbatim
  #+header: :prologue exec 2>&1
  #+begin_src shell
    python3 experiments/recursion/recursion.py
    :
  #+end_src

  #+RESULTS: sum-of-integers-recursive-stress-test
  #+begin_example
  Traceback (most recent call last):
    File "/Users/fchauvel/Documents/perso/aldast-course/content/experiments/recursion/recursion.py", line 5, in <module>
      print(sum_of_integers(1000))
    File "/Users/fchauvel/Documents/perso/aldast-course/content/experiments/recursion/recursion.py", line 4, in sum_of_integers
      return n + sum_of_integers(n-1)
    File "/Users/fchauvel/Documents/perso/aldast-course/content/experiments/recursion/recursion.py", line 4, in sum_of_integers
      return n + sum_of_integers(n-1)
    File "/Users/fchauvel/Documents/perso/aldast-course/content/experiments/recursion/recursion.py", line 4, in sum_of_integers
      return n + sum_of_integers(n-1)
    [Previous line repeated 995 more times]
    File "/Users/fchauvel/Documents/perso/aldast-course/content/experiments/recursion/recursion.py", line 2, in sum_of_integers
      if n==1:
  RecursionError: maximum recursion depth exceeded in comparison
  #+end_example

** Tail Call Optimization

   - What would be the program we have made in RAM assembly?

   #+begin_src asm
     sum: iload n     ;; If n == 1
          subtract 1
          jmp n_is_1       

          load 0      ;; call self with n-1
          add  n  
          subtract 1
          push        ;; push
          call sum    ;; save ip on the stack
          pop tmp
          pop
          iload tmp
          add n       ;; add n
          store tmp
          load 0
          jmp exit
      n_is_1:
          load 1
          store tmp
      exit:
          return tmp  ;; return the total
   #+end_src

   This creates a new activation frame for each sub call. By contrast,
   if we have a tail call, we get

   #+begin_src asm
     sum: iload n     ;; If n == 1
          subtract 1
          jmp n_is_1

          load 1
          add acc
          push        ;; push acc+1

          load 0      ;; call self with n-1
          add  n  
          subtract 1
          push        ;; push n-1

          call sum    ;; save ip on the stack
          jmp exit

      n_is_1:
          load acc
          add 1
          store tmp
        
     exit:
          return tmp  ;; return the total
   #+end_src
    
  - Tail recursion

  #+name: code:sum-of-integers-tail-recursive
  #+begin_src python
    def sum_of_integers(n):
       return do_sum(0, n)

    def do_sum(acc, n):
        if n == 1:xo
            return acc + 1
        return do_sum(acc+n, n-1)
  #+end_src


  #+header: code:sum-of-integers-tco-test
  #+header: :python
  #+header: :noweb strip-export
  #+header: :results output
  #+begin_src python
    <<code:sum-of-integers-tail-recursive>>
    print(sum_of_integers(500))
  #+end_src

  #+RESULTS:
  : 125250

  - Performance of recursive functions

  - Mutually recursive functions
  
  - Correctness?

  - Runtime Analysis of Recursive functions

  - Sample Problems
    - sum of n
    - power of n
    - Reversing an array
    - Computing the change
    - The Hanoi Towers
    - Generation of all the permutations and combinations

  - Recursive Data Structures

  - Escaping a maze
    See

  - Resources
    - [[https://en.wikipedia.org/wiki/Recursion_(computer_science)][Recursion at Wikipedia]]

* Introduction

  #+header: :results output
  #+begin_src scheme
    (define (sum-to n)
      (if (= n 1) 1
          (+ n (sum-to (- n 1)))))

    (print (sum-to 10))
  #+end_src

  #+RESULTS:
  : 55

  #+name: code:sum-of-even
  #+header: :results output
  #+begin_src scheme
    (define (sum-of-even n)
      (cond
       [(= n 0) 0]
       [(= (remainder n 2) 1) (sum-of-even (- n 1))]
       [else (+ n (sum-of-even (- n 2)))]))

    (print (sum-of-even 10))
    (print (sum-of-even 1))
    (print (sum-of-even 2))
    (print (sum-of-even 13))
  #+end_src

  #+RESULTS: code:sum-of-even
  : 300242
  
* Recursive Structure

  

* Lab Session

  - Drawing fractals
