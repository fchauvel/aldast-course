#+title: Stacks and Queues
#+subtitle: Introduction to Abstract Data Types
#+author: Franck Chauvel
#+language: en

#+SETUPFILE: ../templates/style.org

* Introduction

  In this lecture we will explore the concept of /abstract data types/
  (ADT) using two common examples, namely /stacks/ and /queues/. ADT
  help us distinguish between specification and the implementation.

* Stacks

** Arithmetic Expressions
  
** What is a Stack?

   So what is a stack?

   #+headers: :cmdline --transparent
   #+headers: :results graphics file
   #+headers: :exports results
   #+headers: :cache yes
   #+headers: :file ../assets/images/stacks.png
   #+begin_src ditaa

         push                             pop
     +----------+                     +----------+
     | incoming |                     | outgoing |
     |   item   |-=----+      +-=---->|   item   |
     +----------+      |      |       +----------+
                       |      |
                       |      |
                   :   |      |   :
                   |   v      |   |
                   +--------------+   ^
     top --------->|    Item 4    |   |
                   +--------------+   |
                   |    Item 3    |   |
                   +--------------+   | length
                   |    Item 2    |   |
                   +--------------+   |
                   |    Item 1    |   |
                   +--------------+   v
     ------=--------------------------------------
                        bottom
                (nothing comes this way)

   #+end_src

   #+caption: Pushing onto and popping from a stack
   #+name: fig:stack
   #+RESULTS:
   [[file:../assets/images/stacks.png]]

   What operations are legal on a stack:

   * ~push(item)~ places a new item on the top of the stack
   * ~pop(): Item~ removes and return the top of the stack
   * ~top(): Item~ returns (but does not remove) the top of the stack
   * ~is_empty(): Boolean~ True if the stack does not contains any items
   * ~length(): Integer~ returns the number of items in the stack

   Not that stack can have a fixed capacity, in which case they will
   offer an ~is_full(): Boolean~ operation, which is true if the
   length reaches the predefined capacity.

   
** Linked lists or Arrays?

   How would you implement a stack? Would you use an array of a list?

   Actually both are possible, and it depends on the use-case.

** Example: Using an Array

    #+begin_src ruby -n -r
      def length(stack)
        return stack.length
      end

      stack = Array.new
      puts "Length: #{length(stack)}"
    #+end_src

    #+RESULTS:
    : nil
   
*** Push

    #+name: code:push
    #+begin_src ruby -n -r
      def push(stack, item)
        stack.append(item)
      end
    #+end_src

    #+name: code:push-tests
    #+headers: :exports results
    #+headers: :results output
    #+headers: :noweb strip-export
    #+begin_src ruby -n -r
      <<code:push>>
      stack = []
      push(stack, 2)
      push(stack, 3)

      puts "Stack: #{stack}"
    #+end_src

    #+RESULTS:
    : Stack: [2, 3]




*** Pop

    #+name: code:pop
    #+begin_src ruby -n -r
      def pop(stack)
        return stack.pop()
      end
    #+end_src

    #+name: code:pop-tests
    #+headers: :exports both
    #+headers: :results output
    #+headers: :noweb strip-export
    #+begin_src ruby -n -r
      <<code:push>>
      <<code:pop>>
      stack = []
      push(stack, 2)
      push(stack, 3)
      puts "Stack: #{stack}"
      pop(stack)
      puts "Stack: #{stack}" 
    #+end_src

    #+RESULTS: code:pop-tests
    : Stack: [2, 3]
    : Stack: [2]


*** Top

*** Length

* Abstract Data Types

  A stack is not a data structure per se, but an /abstract data type/
  or ADT for short. An ADT defines the operations and their
  consequences, but it does not define the implementation.


  - ADT
    - Collection of data??
    - operations
    - axioms

  As for the stack, we have already looked at its operations, namely
  create, push, pop, empty, size, and top. Let's now look at the
  domains and the axioms needed to complete this ADT.

  - ~create~, create a new stack
    \[
     create: \varnothing \to Stack
    \]

  - ~push(item)~ add the given item on the top the stack
    \[
    push: Stack \times Item \to Stack
    \]

  - ~pop~ remove the element lying on top of the stack
    \[
    pop: Stack \to Stack \cup \{ Error \}
    \]

  - ~size~ returns the numberof items in the stack
    \[
    size: Stack \to \mathbb{N}
    \]

  - ~isEmpty~ true if and only if there is no item in the stack
    \[
    empty: Stack \to \mathbb{B}
    \]

  - ~top~ returns the item lying on the top.
    \[
    top: Stack \to Item \cup \{Error\}
    \]

  Now we can defines the axioms. There is possible many ways to write
  them, but here is the list I am thinking of:
  1. A list is initially empty, that is:
     \[
      empty(create())
      \]
  2. a stack is empty if and only if its has no items
     \[
     \forall \, s \in Stack, \\
     \qquad empty(s) \iff size(s) = 0
     \]
  3. ~pop~ fails given an empty stack, that is:
     \[
     \forall \, s \in Stack, \\
     \qquad empty(s) \iff pop(s) = error
     \]
  4. ~pop~ fails given an empty stack, that is:
     \[
     \forall \, s \in Stack, \\
     \qquad empty(s) \iff top(s) = error
     \]
  5. ~pop~ removes the last item pushed onto the stack
     \[
     \forall \, s \in Stack, \\
     \qquad \forall \, i \in Item, \\
     \qquad\qquad pop(push(s, i)) = s
     \]
  6. ~pop~ decreases the stack size by 1
     \[
     \forall \, (s_1, s_2) \in Stack^2, \\
     \qquad s_2 = pop(s_1) \iff size(s_2) = size(s_1) - 1
     \]
  7. ~push~ increases the stack size by 1
     \[
     \forall \, (s_1, s_2) \in Stack^2, \\
     \qquad \forall \, i \in Item, \\
     \qquad\qquad s_2 = push(s_1, i) \iff size(s_2) = size(s_1) + 1
     \]
  8. ~top~ returns the last item pushed onto the stack
     \[
     \forall \, s \in Stack, \\
     \qquad \forall \, i \in Item, \\
     \qquad\qquad top(push(s, i)) = i
     \]

 

  - data type
    - Contribution of B. Liskov (Turing award winner 2010)
    - define by its operations rather than its data structure

  - What is a good ADT?
    - representation independence
    - preserve invariants
      - Ex: Immutability
        - Beware of the mutability of attributes!

  - Abstract values vs. representation values

  - See [[https://fmfi-uk.hq.sk/Informatika/Principy%20Tvorby%20Software/OOSC/ADTO9G.PDF][Chapter 6, of OOSC by B. Meyer]]
    
** Definition


   

** Pre and Post conditions


   #+headers: :classname Stack
   #+headers: :exports code
   #+headers: :results output
   #+begin_src java -n -r
      public class Stack<Item> {

          private final int capacity;
          private final Object[] items;
          private int length;

          public Stack(int capacity) {
              this.capacity = capacity;
              this.items = new Object[capacity];
              this.length = 0;
          }

          public void push(Item item) {
              this.length += 1;
              this.items[length-1] = item;
          }

          public Item top() {
            return (Item) this.items[this.length-1];
          }

          public boolean isEmpty() {
             return this.size() == 0;
          }

          public Item pop() throws IllegalStateException {
              final int previousLength = this.length;
              if (this.isEmpty())
                 throw new IllegalStateException("Cannot 'pop' the empty stack!"); 

             Item top = this.top();
             this.items[this.length-1] = null;
             this.length -= 1;

             if (this.length != previousLength-1)
                throw new RuntimeException("Invalid pop behaviour")

             return top;
          }

          public int size() {
             return this.length;
          }

          public static void main(String[] args) {
              Stack<Integer> stack= new Stack<Integer>(100);
              stack.push(20);
              stack.push(22);
              System.out.println("Size: " + stack.size());
          }

     }
   #+end_src

   #+RESULTS:
   : Size: 2

** Unit Testing


   #+begin_src java
     @Test
     public void testPopDecreasesSize() {
        Stack<Integer> stack = new Stack<Integer>(10);
        stack.push(5);
        stack.push(10);

        stack.pop();
   
        assertEquals(1, stack.size());
      }
   #+end_src
   
   
** Examples

   Numbers, Interval, List, Queues, Set, Dictionary,

* Queues


* Recap


* Resources

  - [[https://en.wikipedia.org/wiki/Queue_(abstract_data_type)][Wikipedia on queues]]
  - [[https://en.wikibooks.org/wiki/Data_Structures/Stacks_and_Queues#Evaluation_of_an_Infix_Expression_that_is_Fully_Parenthesized][Wikibook on stacks and queues]]
  - [[https://dspace.mit.edu/bitstream/handle/1721.1/106923/6-005-fall-2011/contents/lecture-notes/MIT6_005F11_lec06.pdf][Lecture notes from MIT on ADT]]
  - [[https://fmfi-uk.hq.sk/Informatika/Principy%20Tvorby%20Software/OOSC/ADTO9G.PDF][Chapter 6 of OOSC by B. Meyer]]
