#+titile: Faster Sorting
#+subtitle: More Advanced Sorting Algorithms
#+author: Franck Chauvel
#+language: en

#+SETUPFILE: ../templates/style.org


* Introduction

  - Sorting is important, but all the solution we found are polynomial
  - Can we do any better?

* Merge Sort

  #+header: :results output
  #+begin_src scheme
    (define (merge left right)
      (cond [(empty? left) right]
            [(empty? right) left]
            [(< (first left) (first right))
             (cons (first left)
                   (merge (rest left) right))]
            [else
             (cons (first right)
                   (merge left (rest right)))]))

    (define (merge-sort list)
      (cond [(= (length list) 1) list]
            [else
             (let
                 ([cut (quotient (length list) 2)])
               (merge (merge-sort (take list cut))
                      (merge-sort (drop list cut))))]))

    (print (merge-sort '(9 3 2 4 5 1 8 7 6)))
  #+end_src

  #+RESULTS:
  : '(1 2 3 4 5 6 7 8 9)
  

* Quick Sort

** Out of place

   
  #+name: code:py-quick-sort
  #+begin_src python

    def quick_sort(array):
        if len(array) < 2:
            return array
        left, pivot, right = partition(array)
        return quick_sort(left) \
            + [pivot] \
            + quick_sort(right)

    def partition(array):
        smaller = []
        greater = []
        pivot = len(array) // 2
        for index in range(len(array)):
           if index != pivot:
               if array[index] <= array[pivot]:
                   smaller.append(array[index])
               else:
                   greater.append(array[index])
        return smaller, array[pivot], greater

  #+end_src

  #+header: :results output
  #+header: :noweb strip-export
  #+header: :python python3
  #+begin_src python
    <<code:py-quick-sort>>
    array = [9, 1, 8, 2, 7, 3, 6, 4, 5]
    sorted_array = quick_sort(array)
    print(sorted_array)
  #+end_src

  
*** Space Complexity
  
    partition takes n items: space(n) = n

  #+header: :results graphics file
  #+header: :file ../assets/images/quick_sort_space.png
  #+begin_src R

    space <- function(n) {
      if (n == 1) 1
      else {
         if (n %% 2 == 0)
           n + space(n/2)
         else
           n + space((n-1)/2)
      }
    }

    space2 <- function(n) {
      if (n %% 2 == 0) {
        2*n - n*2^(-floor(log2(n)))

      } else {
         2 * (n+1) - log2(n+1) - 1
      }
    }

    sizes <- seq(1:100);
    spaces <- sapply(sizes, space);
    spaces2 <- sapply(sizes, space2);

    plot(sizes, spaces, type="l");
    lines(sizes, spaces2, type="l", lty=1, col="red");
  #+end_src
              
  #+RESULTS: 
  [[file:../assets/images/quick_sort_space.png]]


*** Time Complexity

**** Best Case

\begin{align*}
\text{sort}_{t}(n) = \begin{cases}
0 & \text{if } n < 2 \\
\text{partition}_{t}(n) + 2 \cdot \text{sort}_{t}(\frac{n-1}{2}) & \text{otherwise}
\end{cases}
\end{align*}

Or we know that $\text{partition}_t(n) = n$ so we get:

\begin{align*}
\text{sort}_{t}(n) = \begin{cases}
0 & \text{if } n < 2 \\
n + 2 \cdot \text{sort}_{t}(\frac{n-1}{2}) & \text{otherwise}
\end{cases}
\end{align*}

We can try to expand this recurrence relation to see how if we can see
a pattern. Let's try with $sort_t(\frac{n-1}{2})$

\begin{align*}
\text{sort}_t(\frac{n-1}{2}) & = \frac{n-1}{2} + 2 \cdot \text{sort}_t(\frac{\frac{n-1}{2}-1}{2}) \\
                   & = \frac{n-1}{2} + 2 \cdot \text{sort}_t(\frac{n-3}{4}) \\
\end{align*}

We can now plug this into the definition of $sort_t(n)$ to see whether
we can simplify it:

\begin{align*}
  \text{sort}_t(n) & = n + 2 \cdot \text{sort}_t(\frac{n-1}{2}) \\
   & = n + 2 \cdot \text{sort}_t(\frac{n-1}{2}) \\
   & = n + 2 \cdot \left[ \frac{n-1}{2} + 2 \cdot \text{sort}_t(\frac{n-3}{4}) \right]\\
   & = n + n - 1 + 4 \cdot \text{sort}_t(\frac{n-3}{4})\\
\end{align*}

We can workout the term $$ as follows:

\begin{align*}
\text{sort}_t(\frac{n-3}{4}) & = \frac{n-3}{4} + 2 \cdot \text{sort}_t(\frac{\frac{n-3}{4}-1}{2}) \\
                   & = \frac{n-3}{4} + 2 \cdot \text{sort}_t(\frac{n-7}{8}) \\
\end{align*}


\begin{align*}
  \text{sort}_t(n) & = n + n - 1 + 4 \cdot \text{sort}_t(\frac{n-3}{4})\\
   & = n + n - 1 + 4 \left[ \frac{n-3}{4} + 2 \cdot \text{sort}_t(\frac{n-7}{8}) \right] \\
   & = n + (n - 1) + (n-3) + 8 \cdot \text{sort}_t(\frac{n-7}{8}) \\
\end{align*}

\begin{align*}
   \text{sort}_t(n) & = \sum_{i = 0}^{\left \lfloor log_2(n) \right \rfloor} n-1-2^i \\
                    & = \left \lfloor log_2(n+1) \right \rfloor \cdot (n-1) - \frac{1-2^{\left \lfloor log_2(n) \right \rfloor}}{1-2} 
\end{align*}
    
  #+header: :results graphics file
  #+header: :file ../assets/images/quick_sort_time.png
  #+begin_src R

    time0 <- function(n) {
      if (n <= 1) {
        0
      } else if (n %% 2 == 0) {
        left <- (n-1) %/% 2
        n + time0(left) + time0(n-1-left)

      } else {
        n + 2 * time0((n-1)/2);
      }
    }

    time <- function(n) {
      if (n <= 1) 0
      else {
         n + 2 * time(floor((n-1)/2))
      }
    }

    time2 <- function(n) {
      sum(sapply(0:floor(log2(n)), function(k) {n-(2^k-1)}))
    }

    time3 <- function(n) {
       floor(log2(n)+1) * (n+1) - (1-2^(floor(log2(n))+1))/(1-2)
    }

    sizes <- seq(1:100);
    times <- sapply(sizes, time);
    times2 <- sapply(sizes, time2);

    plot(sizes, times, type="l");
    lines(sizes, times2, type="l", lty=1, col="red");
    lines(sizes, sapply(sizes, time3), type="l", lty=2, col="darkgreen");
    lines(sizes, sapply(sizes, time0), type="l", lty=2, col="blue");
  #+end_src
              
  #+RESULTS: 
  [[file:../assets/images/quick_sort_time.png]]

*** Average Runtime

    Let assume a that the pivot can come up anywhere in the given
    array with equal probability. We can define a random variable P, such that :

    - $P$ represent the position of the pivot after the partitioning
    - $P$ has $n$ values: From 0 to $n-1$
    - Each value has the same probability, that is $\forall\, k in P,
      \; \Pr(P=k) = \frac{1}{n}$

    We can the rewrite  time taken to sort an array of length
    $\ell$ as a function of the final pivot position $P$:

    \begin{align*}
     sort_t(\ell, P) = \begin{cases}
         0 & \text{if } \ell < 2 \\
         partition_t(\ell) + sort(P) + sort(\ell-P-1) & \text{otherwise} \\
     \end{cases}
    \end{align*}

    The average time is the the expected value of the sort function,
    as follows:

    \begin{align*}
        sort_t(\ell, P) &= \begin{cases}
         0 & \text{if } \ell < 2 \\
         partition_t(\ell) + \sum_{k=0}^{\ell-1} \Pr(P=k) \cdot \left(sort(P) + sort(\ell-P-1)\right) & \text{otherwise} \\
     \end{cases} \\
        sort_t(\ell, P) &= \begin{cases}
         0 & \text{if } \ell < 2 \\
         partition_t(\ell) + \sum_{k=0}^{\ell-1} \frac{1}{\ell} \cdot \left(sort(P) + sort(\ell-P-1)\right) & \text{otherwise} \\
     \end{cases} \\
        sort_t(\ell, P) &= \begin{cases}
         0 & \text{if } \ell < 2 \\
         partition_t(\ell) + \frac{2}{\ell} \cdot \sum_{k=0}^{\ell-1} sort(P) & \text{otherwise} \\
     \end{cases}

    \end{align*}

    Let us look first at $sort(\ell) = \ell + \frac{2}{\ell} \cdot
    sum_{k=0}^{\ell-1} sort(k)$. We get

    \begin{align}
      sort(\ell) & = \ell + \frac{2}{\ell} \cdot \sum_{k=0}^{\ell-1} sort(k) \\
      \ell \cdot sort(\ell) &= \ell^2 + 2\cdot \sum_{k=0}^{\ell-1} sort(k) \\
    \end{align}

    If we look at $\text{sort}_t(\ell-1)$ we get:

    \begin{align}
      (\ell-1) \cdot sort(\ell-1) &= (\ell-1)^2 + 2\cdot \sum_{k=0}^{\ell-2} sort(k) \\
    \end{align}

    Now, if we subtract equation X from equation Y, we get

    \begin{align*}
     \ell \cdot \text{sort}_t(\ell) - (\ell-1) \cdot \text{sort}_t(\ell-1) & = \ell^2 - (\ell-1)^2 + 2 \cdot \text{sort}_t(\ell-1) \\
     \ell \cdot \text{sort}_t(\ell) - (\ell-1) \cdot \text{sort}_t(\ell-1) & = 2\ell - 1 + 2 \cdot \text{sort}_t(\ell-1) \\
     \ell \cdot \text{sort}_t(\ell)  & = 2\ell - 1 + 2 \cdot \text{sort}_t(\ell-1) + (\ell-1) \cdot \text{sort}_t(\ell-1) \\
     \ell \cdot \text{sort}_t(\ell)  & = 2\ell - 1 + (\ell +1) \cdot \text{sort}_t(\ell-1) \\
     \ell \cdot \text{sort}_t(\ell)  & = (\ell +1) \cdot \text{sort}_t(\ell-1) + 2\ell - 1 \\
    \end{align*}

    Now, we divide the whole thing by $\ell\cdot(\ell+1)$ and we get:
    \begin{align*}
        \frac{\text{sort}_t(\ell)}{\ell+1}  & = \frac{\text{sort}_t(\ell-1)}{\ell} + \frac{2\ell - 1}{\ell \cdot (\ell+1)} \\
        \frac{\text{sort}_t(\ell)}{\ell+1}  & = \left[ \frac{\text{sort}_t(\ell-2)}{\ell-1} + \frac{2 \cdot(\ell-1) - 1}{(\ell-1) \cdot \ell} \right] + \frac{2\ell - 1}{\ell \cdot (\ell+1)} \\
        \frac{\text{sort}_t(\ell)}{\ell+1}  & = \frac{\text{sort}_t(\ell-2)}{\ell-1} + \frac{2\cdot\ell-3}{(\ell-1) \cdot \ell} + \frac{2\ell - 1}{\ell \cdot (\ell+1)} \\
        \frac{\text{sort}_t(\ell)}{\ell+1}  & = \left[ \frac{\text{sort}_t(\ell-3)}{\ell-2} + \frac{2(\ell - 3)-1}{(\ell-2) \cdot (\ell-1)} \right] + \frac{2\cdot\ell-3}{(\ell-1) \cdot \ell} + \frac{2\ell - 1}{\ell \cdot (\ell+1)} \\
    \end{align*}

  #+header: :results graphics file
  #+header: :file ../assets/images/quick_sort_avg_time.png
  #+begin_src R
    N <- 20;
    time <- function(n) {
      if (n < 2) {
        1
      } else {
        n + (2/n) * sum(sapply(0:n-1, function(k){time(k)}))
      }
    }

    close_form <- function(n) {
      a <- (2 + N) / N;
      return((1-a^n)/(1-a));
    }

    approximation <- function(n) {
      n * log(n)
    }

    sizes <- 1:N
    plot(sizes,
         sapply(sizes, time),
         type="l",
         col="red");
    lines(sizes,
          sapply(sizes, close_form),
          col="darkgreen");
    lines(sizes,
          sapply(sizes, approximation),
          col="darkblue");
  #+end_src

  #+RESULTS:
  [[file:../assets/images/quick_sort_avg_time.png]]
    
  #+name: code:py-quick-sort-inplace
  #+header: :python python3
  #+begin_src python
    def quick_sort(array, lower, upper):
         if (upper-lower) < 2: return
         pivot = partition(array, lower, upper)
         print(lower, upper, array[pivot], array[lower:upper])
         quick_sort(array, lower, pivot)
         quick_sort(array, pivot+1, upper)

    def partition(array, lower, upper):
         pivot = (lower + upper) // 2
         swap(array, lower, pivot)
         left, right = lower+1, upper-1
         while left <= right:
              if array[left] <= array[lower]:
                   left += 1
              else:
                   swap(array, left, right)
                   right -= 1
         
         swap(array, lower, left-1)
         return left-1

    def swap(array, first, second):
         tmp = array[first]
         array[first] = array[second]
         array[second] = tmp
  #+end_src

  #+header: :results output
  #+header: :noweb strip-export
  #+header: :python python3
  #+begin_src python
    <<code:py-quick-sort-inplace>>
    array = [9, 6, 2, 3, 1, 4, 7, 8, 0, 5]
    quick_sort(array, 0, len(array))
    print(array)
    #array = [7, 8, 7, 6]
    #pivot = partition(array, 0, len(array))
    #print(pivot, array)
  #+end_src

  #+RESULTS:
  : 0 10 4 [1, 0, 2, 3, 4, 7, 8, 9, 5, 6]
  : 0 4 2 [1, 0, 2, 3]
  : 0 2 0 [0, 1]
  : 5 10 9 [6, 8, 7, 5, 9]
  : 5 9 7 [6, 5, 7, 8]
  : 5 7 5 [5, 6]
  : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  
   
  #+name: code:quick-sort
  #+begin_src scheme
    (define (quick-sort lst)
      (if (< (length lst) 2)
          lst
          (let*
              ([pivot (pick-pivot lst)]
               [parts (qpartition lst pivot)])
            (append (quick-sort (first parts))
                    (make-list (- (length lst)
                                  (+ (length (first parts))
                                     (length (rest parts))))
                               pivot)
                    (quick-sort (rest parts))))))

    (define (qpartition list pivot)
      (if (empty? list)
          (cons '() '())
          (let
              ([partitions (qpartition (rest list) pivot)])
            (cond [(< (first list) pivot)
                   (cons (cons (first list) (first partitions))
                         (rest partitions))]
                  [(> (first list) pivot)
                   (cons (first partitions)
                         (cons (first list) (rest partitions)))]
                  [else partitions]))))

    (define (pick-pivot list)
      (let ([index (quotient (length list) 2)])
        (list-ref list index)))

  #+end_src

  #+name: code:quick-sort-test
  #+header: :noweb strip-export
  #+header: :results output
  #+begin_src scheme
    <<code:quick-sort>>
    (let ([data '(2 3 1 4 7 6 2 9 0 1 )])
       (println (qpartition data (pick-pivot data)))
       (println (quick-sort data))
       )
  #+end_src

  #+RESULTS: code:quick-sort-test
  : '((2 3 1 4 2 0 1) 7 9)
  : '(0 1 1 2 2 3 4 6 7 9)
  

* Radix Sort


* References

  
