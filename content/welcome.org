#+title: Let's Get Started
#+subtitle: Welcome & Practiticalities
#+author: Franck Chauvel
#+date: May 22, 2021

#+SETUPFILE: ../templates/style.org


* Welcome

  Welcome to this course IDATA2302 on /Algorithms and Data
  Structures/. This is Bachelor-level course in Computer Science,
  given at NTNU, the [[https://www.ntnu.edu][Norwegian University of Science and
  Technology]].

  My name is Franck[fn:fchauvel] and I do hope you will find this
  course useful.

  I have prepared this course as well as I could with the time and
  energy I had. I reviewed it, reviewed it again, and got the material
  read by colleagues, but I remain responsible for the errors you will
  find. Please let me know if you find any, big ones, typos, broken
  links, etc. Here is my email: [[mailto:franck.chauvel@gmail.com][franck.chauvel@gmail.com]].

   
* What is that All About?

  Let's get started! What are /data structures and algorithms/ all
  about? It is about understanding how to solve problems with
  computers, and, to be precise, how to solve problems
  /efficiently/. But let start with the start, that is,
  computers\nbsp...

  We use computers on an hourly basis: Our mobile phones, tablets, TV,
  cars, or refrigerators to name only a few. They are all computers, they all includes
  processors, memories, and some sort of input/output devices to
  communicate.  We use them for various tasks, taking pictures,
  watching movies, sending messages, browsing the Internet, you name
  it. All these tasks are about /processing data/.

  #+begin_note
  *Data, information and knowledge* are the different concepts that
   form [[https://en.wikipedia.org/wiki/DIKW_pyramid][DIKW pyramid]]. /Data/ includes all the raw signals that we
   perceive from our environment. Information is data processed to
   answer "who", "what", "when", and "where", whereas /knowledge/ is
   then the "how" and "why". Kind of theoretical nuances\nbsp more can
   be found in [cite:henry1974].
  #+end_note

** Algorithms

   But how does a computer knows what to do with that data?  Well,
   some people gave it a /recipe/, that is /a sequence of
   instructions/ that the computer carefully follows\nbsp... just like we
   follow recipes from our cookbook. These recipes are named
   software, and software engineers write them.

   I like this analogy with cooking. A cooking recipe not only reminds
   us about the steps, but also about the ingredients! For example, I
   use 250 g of flour, 4 eggs, 600 ml of milk, 100 g of sugar and 2
   tablespoons of rum when I cook pancakes. My recipe also includes
   the /sequence of steps/ to follow. For my pancakes, the steps are:

     1. Mix the egg with sugar;
     2. Add the flour, gradually diluting the milk when you need;
     3. Add the rum;
     4. Let it sleep overnight;
     5. Place a ladle of mix on a hot pan (previously greased), and
        fry for about 2 minutes;
     6. Turn over the pancake and fry the other side for less than a
        minute.

   Algorithms are to computers what the cooking recipes are to the
   cooks: *sequences of instructions* (and ingredients) so the
   computer knows what to do with our data!

** Data Structures
   
   Easy, right? /But, what about data structures then?/ Data
   structures are the kitchen storage organization. When ingredients
   are nicely organized (say in small jars ordered by name), then the
   chef be efficient, and we If. won wait long. If the kitchen is
   messy and the chef has to rummage through the storage room to find
   every spices, well\nbsp... we will wait longer. Data structures are
   ways to organize our data that let the computer work as efficiently
   as possible.

   But "efficiently" is still rather vague---I agree. "Efficient" here
   means two things: Short runtime and low memory consumption. The
   "runtime" is the time the algorithm takes to complete. Just like
   when I cook I favor recipes that don't take too long, I don't want
   the computer to spend hours sorting my contacts by name. Turning to
   the memory consumption, it is the memory the computer needs to
   store its intermediate results. Similarly, when I cook, I don't like
   recipes that require a lot of equipment, for example, first boil
   the meat in a pot, then grill it in the oven, while stir frying the
   vegetables in another, the making the sauce in a third, to finally put
   everything in my serving plate. That was the last stretch of my
   cooking analogy---I promised.

   At that point, we have set our target: *Learn how to organize
   data so that algorithms are as fast as possible*.
   
** Why Does it Matter?

   Why does all that matter? In my view, writing efficient algorithms
   is one aspect that distinguishes a hobbyist from a
   professional. The professional programmer delivers quality because
   she takes pride in what she is doing. But a professional is also
   accountable when things go bad---and it happens. If this picks your
   curiosity, R. Martin discusses professionalism in software
   engineering in Chapter 1 of his book "Clean Coder"
   [cite:martin2011]. As you engaged into this Computer Science course
   at NTNU, I assume you aspire to become a professional software
   engineer.
  
   A direct consequence of this is that job interviews, especially for
   bigger software companies, are loaded with technical questions
   about data structures and algorithms. Questions like "If I give you
   two ordered lists of users, how fast can you merge them while
   preserving the ordering?". Companies may even use online services such
   as [[https://www.hackerrank.com][HackerRank]] or [[https://www.codility.com][Codility]] to test your programming skills, but the
   knowledge you need is first and foremost the very topic of this
   course.
   
   Besides, data structure and algorithms is a universal skill
   set. Computer Science is a wide topic, with many specializations
   such as artificial intelligence, computer vision, database,
   compilers, numerical modeling, etc. Data structures and algorithms
   form the common backbone: Every specialization has its own data
   structures, its own algorithms, but all discuss them the same
   way. It helps with all other courses.

   Finally, data structures and algorithm is timeless, because it is
   independent of any given technology. While learning Java, Rust,
   Ruby, Python or Racket requires updating your skills every for
   every new version of these languages, sorting an array, traversing
   a binary tree *does not change*. New data structures may appear but
   those you already master stay relevant.
   

* Course Overview

** Objectives
   
   What will you learn in this course? At a high-level, I see three
   main objectives:

   1. Understand what an algorithm is and what how to estimate its
      efficiency, regardless of the technology.

   2. Get an overview of the most common problems and their commonly
      accepted solutions. There is no need to reinvent the wheel.

   3. Understand where solutions apply, where they do not, and where
      it is unclear so that we have to exercise our judgment.

   From a more technical standpoint, this course covers:

   - /Theoretical foundations/ covering algorithm analysis, random access
     machines, big-O notation and growth orders.

   - /Basic data structures/ such as array, hash-tables, lists, trees,
     and graphs.

   - /Basic algorithms/ such as insertion, deletion, sorting, search,
     and others.
     
  
** Prerequisites

   I hope to on-board as many as possible: Both self-taught hackers
   and a math-oriented mind-set. I added pointers with complementary
   treatments and I would be grateful if you could share so you know
   or find on the way!

   To be inclusive, I limited the prerequisite to the bare
   minimum. You will need to know some high-school mathematics (i.e.,
   basic arithmetic, basic probabilities and logarithms). For the
   rest, I adhere to the [[https://en.wikipedia.org/wiki/Progressive_disclosure][progressive disclosure idea]]: I explain the
   things when I need them.
  
  
** Lectures

   I was given 14 weeks by NTNU for this course and I hope I fitted
   just enough content. I kept the last week for the assessment.

   Each week demands about 8 hours of study: 2 hours of lectures, 4
   hours of exercises and roughly 2 hours of self-study. I further
   divided each of these two-hour lectures into four 30-minute slots
   and the 4 hours of exercises into four one-hour sessions. That
   yields 52 chapters (30 minute lecture & 1 hour of exercise). Table
   [[table:syllabus]] below summarizes them.

   #+include: syllabus.org

** Lab Sessions

   Each lecture comes with an associated one hour lab session. The
   objective of these session is to strengthen our understanding of
   the topic, by exploring related questions. I hope---and
   think---that these are valuable.
   
** Examination & Grading 

   This is an NTNU course and it accounts for a the Bachelor's degree
   in Computer Science so I have to give some grades. I am convinced
   that grades remains an excellent opportunity for feedback and I
   included two home examinations (on Week 5 and Week 10) and 
   weekly quizzes to complement the final examination.

   The two home examinations and the final examination are mandatory
   and count in the final grade. The final examination is a mandatory
   4 hour examination---old style, I agree.

   All examinations follow the same blueprint: Four independent
   problems, each worth of 25 points. The first focuses on basic
   notions, the two following ones are variations of the chapters'
   exercises, but the final one requires a deeper understanding. By
   going carefully through the material, everyone should get at
   least 75. Your overall score, which determines your grade, is given
   as follows: \[ Overall = 0.75 \times final + (0.25 \times
   \max(home_1, home_2) ) \]
   
   Given the overall scores, the grades follow the scale shown in
   Table [[table:grading]]. You need at least E to pass.

   #+caption: Grading scale. Minimum and and maximum are included.
   #+name: table:grading
   | Grade    | Min. Score | Max. Score |
   |----------+------------+------------|
   | A        |         90 |        100 |
   | B        |         80 |         89 |
   | C        |         60 |         79 |
   | D        |         50 |         59 |
   | E        |         40 |         49 |
   |----------+------------+------------|
   | F (fail) |          0 |         39 |
    

   
* Suggested Readings

  I have not settled down on one specific textbook. I feel the
  textbook one needs depends on one background, so I chose to list
  several text book that give different treatment of the subject.

  

bibliographystyle:unsrt
bibliography:~/notes/references.bib    

[fn:fchauvel] /Who Am I?/ Not that it matters, but here is a mini
  biography for the curious. I work as a software engineer for [[http://axbit.com][Axbit]],
  a Norwegian Software house. Before that, I worked as a research
  scientist in [[https://www.sintef.no/en/shared-research-areas/software-and-service-innovation/][SINTEF, in the department of Software and Service
  Innovation]], and, even before, I worked as a research engineer in
  [[http://inria.fr][INRIA (France)]]. I hold a PhD, a Master's degree and a technical
  bachelor's degree in Software Engineering.
