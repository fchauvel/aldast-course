#+title: Self-balancing Trees
#+subtitle: AVL Trees
#+author: Franck Chauvel
#+date: Sep. 24, 2021



* Balance Factor

  #+begin_src java
    public int height() {
        int leftHeight = 0;
        int rightHeight = 0;
        if (this.hasLeftChild()) leftHeight = left.height();
        if (this.hasRightChild()) rightHeight = right.height();
        return 1 + Math.max(leftHeight, rightHeight);
    }
  #+end_src


  #+begin_src java
    public int balanceFactor() {
        int leftHeight = hasLeftChild() ? left.height() : 0;
        int rightHeight = hasRightChild() ? right.height() : 0;
        return leftHeight - rightHeight;
    }
  #+end_src

* Rotations

  #+begin_src java
    private AVL<Item> rotateLeft() {
        AVL<Item> newRoot = right;
        AVL<Item> tmp = right.left;
        right.left = this;
        right = tmp;
        return newRoot;
    }
  #+end_src


  #+begin_src java
    private AVL<Item> rotateRight() {
        AVL<Item> newRoot = left;
        AVL<Item> tmp = left.right;
        left.right = this;
        left = tmp;
        return newRoot;
    }
  #+end_src


* Insertion


  #+begin_src java
    public AVL<Item> insert(Item givenItem) {
        int difference = this.item.compareTo(givenItem);
        if (difference > 0)  {
            return insertLeft(givenItem);

        } else if (difference < 0) {
            return insertRight(givenItem);

        } else {
            throw new RuntimeException("Duplicated item " + item);
        }
    }

    private AVL<Item> insertLeft(Item givenItem) {
        if (hasLeftChild()) {
            this.left = this.left.insert(givenItem);
            if (this.balanceFactor() > 1) {
                int side = this.left.item.compareTo(givenItem);
                if (side > 0) {
                    return this.rotateRight();
                } else if (side < 0){
                    this.left = this.left.rotateLeft();
                    return this.rotateRight();
                }
            }

        } else {
            this.left = new AVL(givenItem);

        }
        return this;
    }

    public AVL<Item> insertRight(Item givenItem) {
        if (hasRightChild()) {
            this.right = this.right.insert(givenItem);
            if (this.balanceFactor() < -1) {
                int side = this.right.item.compareTo(givenItem);
                if (side < 0) {
                    return this.rotateLeft();
                } else if (side > 0) {
                    this.right = this.right.rotateRight();
                    return this.rotateLeft();
                }
            }

        } else {
            this.right = new AVL(givenItem);
        }
        return this;
    }
  #+end_src


* Deletion

  #+begin_src java
    public AVL<Item> delete(Item givenItem) throws NoSuchElement {
        int difference = this.item.compareTo(givenItem);
        if (difference < 0) {
            return this.deleteRight(givenItem);

        } else if (difference > 0) {
            return this.deleteLeft(givenItem);

        } else {
           return deleteThis();
        }
    }

    private AVL<Item> deleteThis() throws NoSuchElement {
        if (hasLeftChild() && hasRightChild()) {
            try {
                AVL<Item> successor = this.findSuccessorAVL(this.item);
                successor.right = this.right.delete(successor.item);
                successor.left = this.left;
                return successor;
            } catch (NoSuccessor error) {
                throw new RuntimeException(error);
            }
        }
        if (hasLeftChild()) {
            return this.left;
        }
        if (hasRightChild()) {
            return this.right;
        }
        return null;
    }

    private AVL<Item> deleteRight(Item givenItem) throws NoSuchElement {
        if (hasRightChild()) {
            this.right = this.right.delete(givenItem);
            if (hasLeftChild() && balanceFactor() > 1) {
                int side = this.left.item.compareTo(givenItem);
                if (side > 0) {
                    return this.rotateRight();
                } else if (side < 0){
                    this.left = this.left.rotateLeft();
                    return this.rotateRight();
                }
            }
            return this;
        }
        throw new NoSuchElement();
    }

    private AVL<Item> deleteLeft(Item givenItem) throws NoSuchElement {
        if (hasLeftChild()) {
            this.left = this.left.delete(givenItem);
            if (hasRightChild() && this.balanceFactor() < -1) {
                int side = this.right.item.compareTo(givenItem);
                if (side < 0) {
                    return this.rotateLeft();
                } else if (side > 0) {
                    this.right = this.right.rotateRight();
                    return this.rotateLeft();
                }
            }
            return this;
        }
        throw new NoSuchElement();
    }
  #+end_src
