\documentclass{aldast}


\documentType{Lecture Notes}
\documentNumber{3.1}
\title{Abstract Data Types}
\author{F. Chauvel}

\begin{document}

\maketitle

\begin{abstract}
  We shall look at data, which, as we saw, stands for anything that
  can be encoded using a finite set of symbols. So far we have only
  manipulated numbers, but we shall see here how data types help us
  tame other kinds of data such as floating point numbers, characters,
  as well as compounds such as records, arrays, etc. We will introduce
  abstract data types (ADT) as a means to describe these data types
  regardless of their underlying symbolic representation.
\end{abstract}


\section*{Introduction}

So far we have used only numbers, but in real-life, we need a little
more. We want text, images, colors, sounds, dates, 2D points, users
records, etc. In this lecture, we will look at data types, what they 

\begin{itemize}
  \item How to represent more than just numbers with symbols?
  \item How to move beyond int, float, characters and define our how data types 
  \item What matters from an algorithmic perspective?

\end{itemize}
How can we do that with only a limited set of symbols?
We need encodings.
 

\section{Data \& Data Types}

\subsection{Symbolic Representation}

If we want to manipulate a specific kind of data with a machine, the
first step is to find a way to represent that with the machine's
symbols. Once we agreed on a representation format, we can build a I/O
device that would encode and decode such information into the machine
numbers, and in turn we could write algorithms that manipulate them.

\subsection{Encoding Data into Symbols}

% There are many encodings possible
Encodings schemes define how do we represent a given piece of
information with our symbols. There are many you may have heard of,
such as ASCII or Unicode for characters, sign-and-magnitude or
2s-complement for integers, IEEE 754 for floating point values, PNG
for images, etc.

Take ASCII for example, the American standard for information
interchange. ASCII was developed during the 60ies to represent text in
computers and telecommunications. In ASCII, each character occupies 7
bits, so ASCII only accounts for $128=2^7$ character symbols. That is
enough anyway to capture the Latin alphabet, common punctuation
symbols, a few math symbols and more. The character 'A' is represented
by the number 65 or (or 41 in hexadecimal), 'B' by 66, 'C' by 67,
etc. Lowercase letters come a bit further down with 'a' encoded with
97, 'b' with 98, etc.

\paragraph{Decoding Data from Symbols}

The exact opposite of encoding---when we read the information out of
symbols---is known as decoding. Returning to ASCII, decoding the four
bytes \texttt{4A-6F-68-6E} (i.e., 74, 111, 104, 110 as decimal
numbers) would be decoded as the text ``John''.

The key point about decoding is that we need to know the underlying
representation in advance. Given a sequence of symbols, one cannot say what
encoding it comes from. Take again the four bytes \texttt{4A-6F-68-6E} or
example, they can represent:

\definecolor{testColor}{HTML}{4A6F68}
\begin{itemize}
\item The natural number \numprint{1248815214} as a 32-bit integer value
\itemÂ The real number \numprint{3922459.5} as a 32-bit floating point value
\item The text ``John'' in ASCII
\item Some sort of \textcolor{testColor}{greenish color} as an RGBA color
\item etc.
\end{itemize}

At the machine level such encoding/decoding do not matter. In our
simplified RAM architecture, encoding and decoding take place in the
I/O device: It would convert know specific representations and present
information accordingly to the user.


\subsection{Data Types}

Although the machine only care about symbols, programmers likes to
distinguish between different \emph{data types}. Consider the
following Java program that decides whether the user answered yes or
no.

\begin{minted}{java}
  boolean isYes(char anwser) {
    return Character.toUpperCase(answer) == 'Y';
  }
\end{minted}

Java and other statically-typed programming languages make data types
explicit so that the compiler can detect earlier invalid expressions such as
\mintinline{java}{var x = 25 / 'a'}.

\begin{takeaway}
  A \emph{data type} is a set of sequences of symbols (machine word),
  which adhere to a specific representation format and which we
  manipulate with specific procedures.
\end{takeaway}

\paragraph{Primitive Types}

High-level programming languages such as C, Java, Python natively
supports the most common data types. The compilers (or interpreter)
hides the underlying representations from us programmers. These
\emph{primitive} data types include
\begin{itemize}
\item Boolean values (true / false), which come along with
  conjunction (and), disjunction (or), and negation (not) operators.
\item Integer values, which support both arithmetic operations as
  well as comparisons.
\item Floating point values, which also support both arithmetic
  operations and comparisons
\item Characters, often encoded either in ASCII or in Unicode.
\end{itemize}

\paragraph{Compound Types}

Primitive data types are of what is given by the programming
languages, but we very often need to create our own data types to
capture domain concepts, such as color, 2D point, dates, time, user
record, etc.

There are three ways to create new types out of existing types, namely
structures, arrays, and unions.
\begin{itemize}
\item Structures (also known as record or tuples) capture a fixed
  number of data of different types. For example, in C, a date like
  ``June 30, 2002'' could be represented by the following structure:
  \begin{minted}{c}
    struct Date {
      int day;
      int month;
      int year;
    };
  \end{minted}
  Structures surface as classes in object-oriented languages like
  Java, Python or JavaScript.
\item Arrays capture a fixed number of data from the same
  type. For example, 
\item Unions alternative data that can belong to different data
  type.
\end{itemize}

% Encoding create types


In statically-typed language like C/C++, Pascal, Java and the likes,
we explicitly state these conventions to find errors and
miss-use. The hope is that by giving away some flexibility, the compilers can spot
typing mistakes.


% Data have multiple interpretation
We saw that programs process \emph{data}: Sequences of symbols stored
in memory. For example, our RAM manipulates only numbers in base 10
using Arabic digits (0, 1, 2, 3, \ldots 9). While the RAM only uses
numbers, theses numbers occurs in various roles: Some represent memory
addresses (e.g., the \texttt{IP} register), some represent opcodes
(e.g., 1 denotes \texttt{LOAD}), and some represent numbers. A single
sequence of symbols can have multiple interpretations, and in
general---without more information---one cannot say what a bunch of
symbols stands for. Take a single number, say 7 for example: We cannot say
for sure if this is an address, an opcode, or just the value
seven. This matters because if, by mistake, we use it in place of an
opcode, the RAM would just halt.

What defines the interpretation of symbols then? It is how and where
we use them. If I read a number in the \texttt{IP} register, I know
for sure that it is an address. If I read the instruction \texttt{LOAD
  34}, I know that $34$ is a value, etc. The same apply for general
purpose languages. A boolean value supports logical operations like
conjunction (and), disjunction (or) and negation (not). Integer values
can be added, compared, subtracted, etc.

\section{Compound Data Types}

Example: Date, Color, Coordinate/Vector/Complex number, Card (suit, value), Instruction



\section{Abstract Data Types}


     




\bibliographystyle{acm}
\bibliography{references}

\end{document}